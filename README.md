# Это тестовая работа сделанная в 08-2024.
### Суммарно потрачено ~20 часов

Так как все актульные наработкии находятся под авторским правом моего работодателя, то весь код писался с нуля, за исключением используемых библеотек, чтобы сократить время и не изобретать местами велосипед.
Местами получилось грубо, т.к. весь код иправизация в выходной и после рабочего дня.

## Основные решения, используемые либы. 
### A.k.a. "Почему и зачем".
Всё решения было забинжено через VConteiner (DI). Его перфоманс и простота подкупает. Точка входа MainLifetime (AppContext gameObject на сцене)
Условно весь биндинг разделён на 3 группы.
1) Базы данных. Хранят информацию о конфигах и AssetReference, сами базы хранятся в папке Resources/Databases. Они не имею ссылок на сложные управляемые объекты и хранят только примитивные данные. Что значит не повлияют на время загрузки и размер основного приложения.
2) Провайдеры данных. Это "всё" что мы можем превратить в управляемый юнити объект (UnityEngine.Object) или простот какая-то модель. Провайдер реализует биндинг данных из конфига в некий TTarget. Так же всякие EnemiesProvider могут работать с пулом и создавать объект. Биндинг осуществлён через сущность FeatureHandler. Который принимает массив id и может "дать в аренду" некие данные. Когда фича не нужна, её можно dispose. Под фичей можно понимать что угодно. Например персонаж. У него есть в зависимостях оружие например. Его можно забиндить значит. А когда персонаж будет выгружен, мы выгрузим и зависимости.
3) Сервисы. Это некие системы управляющие разными частями игры.

Общение сервесов было сделано через 2 способа. Сорри за костыль. Не до конца успел придумать более лучший способ т.к. обе идеи витали давно в голове и хотелось их опробовать, а тут тестовое подвенулось.
1) VitalRouter - объщение через комнады, код которых догенеривается через SourceGenerator. Наверное лучше было бы большую часть объщения перенести на него. 
2) R3 - реативность. Тут прихожу к выводу, что лучше более ограниченно использовать и местами избыточно оставляет много не кодогенерируемых связей между системами, плюс в теории предположу, что VitalRouter даст больший перфоманс.

## От себя:
Добавил мини локальный мультиплеер. Поэтому для второго игрока кнопки:
1) 0 на цифровой клавиатуре - стрелять. 
2) Стрелки - двигаться
3) 1 и 3 на цифровой клавиатуре - менять скил.
4) У первого игрока движение на wasd
5) Для управления юзал InputSystem, самое сложное было подружить с 1 клавиатурой 2 игроков. Оказалась нужно клон InputActionAsset создать, чтобы можно было назначить... 4 часа убил на это.
6) Для локации заюзал TileMap, место спавна игроков реализованно через специальный тайл SpawnPointTile (подглядел идею у семплов M3 юнитёвых)

## Заметки по перфомансу:
1) Уже к финалу поленился с оптимизацией и расчёт всех колизий занимает O(enemy * players * (projectile + 1)), надеюсь не сильно критично
2) Чтобы оптимизировать снаряды и не париться сильно с их логикой движения заюзал ParticleSystem. 
3) Чуть использовал идеи ECS чтобы оптимизировать расчёт коллизий. Сделав их расчёт в 3 этапа. OnBeginUpdate() + колизии + OnCompleteUpdate()
3.1) Сначало обновляем позиции всех и у оружия запоминаем все партикли через NativeList. 
3.2) Ищем через всех enemy пересечение rect(ов) и дестроим если нужно RemoveAtSwapBack. Если enemy прошёл через все снаряды, наносим урон. Как оптимизацию которую не успел, можно было бы для всех Particle одинм проходом дополнительно находить суманрный Rect и если юнити не входит в него нет смысла ~20-50 снарядах бежать по списку. Типо culling такой.
3.3) Пушим в партикл системы новый буфер и заканчивает обновление колизий.
4) Все пулы использованы через UnityPoolApi
5) Вьюхи все для удобства убиваю. Возможно лучше было бы через SetActive или alpha 0 у canvasGroup. Но я не сильно полировал перезапукаемость компонентов и технически поддержка через setActive есть у View.
6) Оружие и персонажей специально сделал без пулов. 2 игрока не часто будут умирать. А смена оружия тоже происходит не так часто и это по сути 1 Go с партиклами.

## В заключении что не успел, но хорошо было бы:
1) Валидаторы для инспектора
2) Аттрибуты для преобразования string id => dropdown. Чтобы выбирать из доступных сущностей.
3) Структура ссылка на конфиг с валидациями. EntryLink { string Database, string ID } c dropdown поведением в инспекторе.
4) Минимизировать R3 перенеся на VitalRouter. 
5) Перенести осноную работу в сервисы, оставив более чистыми провайдеры (только спан и подобные ему операции)
6) Снизить влияние контролеров. Скорее это "View", тогда у нас будет +- честный MVC, где роль контролера берут на себя сервисы.

# Задание:
>1) На сцене располагается маг (с здоровьем, защитой и скоростью передвижения)
>2) Маг должен уметь двигаться по сцене, поворачиваться (стрелками на клавиатуре) и уметь выпускать заклинания (кнопка Х)
>3) Заклинания у мага должны быть нескольких видов (с разным внешним видом и уроном)
>4) У мага должна быть возможность смены текущего заклинания (кнопки Q и W)
>
>1) Монстры должны быть нескольких видов (с разным внешним видом, количеством здоровья, урона, защиты и скоростью передвижения)
>2) Монстры должны рождаться рандомно за сценой и направляться к магу
>3) На сцене единовременно должно располагаться не более 10 монстров, при смерти одного должен рождаться следующий
>4) При попадании заклинания в монстра его здоровье должно уменьшаться соответственно урону заклинания и защите монстра
>5) При коллизии с магом, его здоровье должно уменьшаться соответственно защите мага и урона от монстра
>
>Размер сцены должен быть ограничен.
По желанию на сцене могут располагаться различные препятствия.
Внешний вид можно обозначить картинкой или цветом.
Расчет урона: здоровье = здоровье урон * защита (0...1).
На графическую составляющую не стоит тратить много времени, она не влияет на оценку решения. Можно использовать готовые ассеты или простые фигуры.
>
>В процессе выполнения тестового задания не забывайте о расширяемости и сложности поддержки. А также о производительности полученного решения. Итоговый результат должен обладать свойствами продакшн кода, насколько это возможно в условиях лимитированного времени. ECS использовать нельзя.
>
>Если не получилось устранить все проблемы из-за нехватки времени, опишите, как от них избавиться, если бы это был продакшн код.